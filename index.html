<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Single Hand Energy Core</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #050505;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 2;
        }

        #input_video { display: none; }

        .hud {
            position: absolute;
            bottom: 40px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.5);
            pointer-events: none;
            z-index: 3;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 12px;
        }

        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            background: #444;
            border-radius: 50%;
            margin-right: 8px;
        }
        .active .status-indicator {
            background: #00ffcc;
            box-shadow: 0 0 10px #00ffcc;
        }
    </style>
</head>
<body>

<div class="hud" id="hud">
    <span class="status-indicator"></span>
    <span id="status-text">Loading Vision...</span>
</div>

<video id="input_video"></video>
<canvas id="canvas"></canvas>

<script>
    // --- CONFIGURATION ---
    const CONFIG = {
        baseHue: 210,         // Electric Blue
        hueShift: 50,         // Color shift on expansion
        drag: 0.94,           // Air resistance
        minSpread: 10,        // Radius when pinched (compressed)
        maxSpread: 250,       // Radius when open (expanded)
        particleCount: 12     // Particles per frame
    };

    // --- SETUP CANVAS ---
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let w, h;

    function resize() {
        w = canvas.width = window.innerWidth;
        h = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- STATE ---
    let particles = [];
    let hand = { x: w/2, y: h/2, detected: false };
    let pinchDistance = 0; // 0 (Close) to 1 (Far)
    let tension = 0;       // 1 (High Tension/Pinch) to 0 (Relaxed/Open)

    // --- UTILS ---
    const random = (min, max) => Math.random() * (max - min) + min;

    // --- PARTICLE CLASS ---
    class Particle {
        constructor(x, y, tensionVal) {
            this.x = x;
            this.y = y;
            
            // PHYSICS MAPPING:
            // High Tension (Pinch) = Fast vibration, short life, white/cyan color
            // Low Tension (Open) = High speed, long life, purple/blue color
            
            const angle = random(0, Math.PI * 2);
            
            // If tension is high, particles are explosive but contained
            const speed = 2 + (random(0, 5) * (1 - tensionVal)); 
            
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            
            this.life = 1;
            // Decay is faster when high tension (fizzling out)
            this.decay = random(0.01, 0.04) + (tensionVal * 0.05); 
            
            // COLOR MAPPING:
            // Tension 1 = White/Cyan. Tension 0 = Deep Purple.
            const hue = CONFIG.baseHue + ((1 - tensionVal) * CONFIG.hueShift);
            const saturation = 80 + (tensionVal * 20); // More saturation when pinched
            const lightness = 50 + (tensionVal * 40);  // Brighter when pinched
            
            this.color = `hsla(${hue}, ${saturation}%, ${lightness}%,`;
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;
            
            // Add jitter if high tension
            if(tension > 0.8) {
                this.x += random(-2, 2);
                this.y += random(-2, 2);
            }

            this.vx *= CONFIG.drag;
            this.vy *= CONFIG.drag;
            
            this.life -= this.decay;
        }

        draw() {
            ctx.fillStyle = this.color + this.life + ')';
            ctx.beginPath();
            // Particles are smaller when compressed
            ctx.arc(this.x, this.y, random(1, 3), 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // --- ANIMATION LOOP ---
    function loop() {
        requestAnimationFrame(loop);

        // 1. Clear Screen (Trails)
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = 'rgba(5, 5, 5, 0.2)';
        ctx.fillRect(0, 0, w, h);

        // 2. Logic
        let spawnX = w / 2;
        let spawnY = h / 2;
        
        if (hand.detected) {
            spawnX = hand.x;
            spawnY = hand.y;
            
            // Map pinch distance (pixels) to a 0-1 scale
            // Usually 0px is closed, ~150px is fully open
            let normalizedPinch = Math.min(Math.max(pinchDistance / 150, 0), 1);
            
            // Tension is inverse of distance (Close = High Tension)
            tension = 1 - normalizedPinch;
        } else {
            // Idle animation
            tension = 0.5 + Math.sin(Date.now() / 300) * 0.5;
            spawnY += Math.sin(Date.now() / 1000) * 50;
        }

        // 3. Spawn Particles
        // Spawn more when high tension
        let count = CONFIG.particleCount + (tension * 10);
        
        for(let k = 0; k < count; k++) {
            // Spawn radius logic
            // High Tension = Spawn very close to center (Compression)
            // Low Tension = Spawn in a wider area
            let spawnRadius = CONFIG.minSpread + ((1 - tension) * 20); 
            let r = random(0, spawnRadius);
            let theta = random(0, Math.PI * 2);
            
            let px = spawnX + Math.cos(theta) * r;
            let py = spawnY + Math.sin(theta) * r;
            
            particles.push(new Particle(px, py, tension));
        }

        // 4. Draw Particles
        ctx.globalCompositeOperation = 'lighter';
        
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.update();
            p.draw();
            
            // Physics Constraint:
            // If tension is high, kill particles that go too far (Containment Field)
            if(tension > 0.5) {
                let dx = p.x - spawnX;
                let dy = p.y - spawnY;
                let dist = Math.sqrt(dx*dx + dy*dy);
                // The allowed radius grows as you open your hand
                let limit = CONFIG.minSpread + (pinchDistance * 2); 
                
                if(dist > limit) {
                    p.life -= 0.1; // Kill instantly if outside containment
                }
            }
            
            if (p.life <= 0) particles.splice(i, 1);
        }

        // 5. Visual Guide (Ring around finger)
        if(hand.detected) {
            ctx.strokeStyle = `rgba(255, 255, 255, ${0.1 + tension * 0.5})`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            // Ring size matches the "containment" field
            let ringSize = CONFIG.minSpread + (pinchDistance * 1.5);
            ctx.arc(spawnX, spawnY, ringSize, 0, Math.PI * 2);
            ctx.stroke();
        }
    }

    // --- MEDIAPIPE HANDS ---
    const videoElement = document.getElementById('input_video');
    const hud = document.getElementById('hud');
    const statusText = document.getElementById('status-text');

    function onResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            hud.classList.add('active');
            hand.detected = true;

            const landmarks = results.multiHandLandmarks[0];
            
            // Index Finger Tip (8) position
            hand.x = (1 - landmarks[8].x) * w;
            hand.y = landmarks[8].y * h;

            // Calculate Pinch (Distance between Index Tip 8 and Thumb Tip 4)
            const dx = (landmarks[8].x - landmarks[4].x) * w;
            const dy = (landmarks[8].y - landmarks[4].y) * h;
            let dist = Math.sqrt(dx*dx + dy*dy);
            
            // Smooth the value slightly
            pinchDistance = (pinchDistance * 0.8) + (dist * 0.2);

            if(tension > 0.8) statusText.innerText = "Compressed - High Energy";
            else statusText.innerText = "Expanded - Releasing";

        } else {
            hand.detected = false;
            hud.classList.remove('active');
            statusText.innerText = "Raise one hand";
        }
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    const camera = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 640,
        height: 480
    });

    camera.start();
    loop();

</script>
</body>
</html>
