<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Saturn: Zoom & Rotate</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        
        /* HUD UI */
        #ui-container {
            position: absolute; bottom: 30px; width: 100%;
            display: flex; justify-content: center; pointer-events: none;
            z-index: 10;
        }

        .hud-panel {
            background: rgba(10, 15, 20, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 40px;
            padding: 15px 30px;
            backdrop-filter: blur(10px);
            color: #fff;
            display: flex; gap: 20px; align-items: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .stat-group { text-align: center; }
        .stat-label { font-size: 10px; color: #888; letter-spacing: 2px; text-transform: uppercase; margin-bottom: 4px; }
        .stat-value { font-size: 14px; font-weight: 600; color: #00ff88; font-variant-numeric: tabular-nums;}

        /* Loader */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 999;
            transition: opacity 1s ease-out; pointer-events: none;
        }
        .loader-text { color: white; font-size: 20px; letter-spacing: 8px; font-weight: 300; opacity: 0.8;}

        /* Video (Hidden) */
        #input_video { position: absolute; opacity: 0; pointer-events: none; z-index: -1; }

        /* Crosshair Helper */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            border: 1px solid rgba(255,255,255,0.1); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="loader">
        <div class="loader-text">NEBULA SYSTEM ONLINE</div>
    </div>

    <div id="crosshair"></div>

    <div id="ui-container">
        <div class="hud-panel">
            <div class="stat-group">
                <div class="stat-label">System</div>
                <div class="stat-value" id="status-text">INITIALIZING</div>
            </div>
            <div style="width: 1px; height: 25px; background: rgba(255,255,255,0.2);"></div>
            <div class="stat-group">
                <div class="stat-label">Zoom</div>
                <div class="stat-value" id="zoom-val">1.0x</div>
            </div>
            <div class="stat-group">
                <div class="stat-label">Rotation</div>
                <div class="stat-value" id="rot-val">IDLE</div>
            </div>
            <div style="width: 1px; height: 25px; background: rgba(255,255,255,0.2);"></div>
            <input type="color" id="colorPicker" value="#aaddff" style="width:30px; height:30px; border:none; background:none; cursor:pointer;">
        </div>
    </div>

    <video id="input_video" playsinline></video>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="x-shader/x-vertex" id="vertexshader">
        uniform float uTime;
        uniform float uScale;
        attribute float aRandom;
        attribute float aSize;
        
        varying float vAlpha;
        varying vec3 vColorVariation;

        void main() {
            vec3 pos = position * uScale;
            
            // Internal wave motion (independent of system rotation)
            float angle = uTime * 0.1 * aRandom;
            float s = sin(angle);
            float c = cos(angle);
            
            // Warp effect when scaling up
            if(uScale > 3.0) {
                pos.z += sin(uTime * 10.0 + pos.x) * 0.5;
            }

            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_Position = projectionMatrix * mvPosition;

            // Twinkle
            float twinkle = sin(uTime * 3.0 + aRandom * 25.0);
            twinkle = smoothstep(-1.0, 1.0, twinkle);

            // Dynamic Sizing
            float finalSize = aSize * (0.6 + 0.6 * twinkle);
            gl_PointSize = finalSize * (350.0 / -mvPosition.z);
            
            vAlpha = 0.3 + 0.7 * twinkle;
            vColorVariation = vec3(1.0, 1.0 - aRandom * 0.2, 1.0 + aRandom * 0.2); 
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform vec3 uColor;
        varying float vAlpha;
        varying vec3 vColorVariation;

        void main() {
            float r = length(gl_PointCoord - vec2(0.5));
            if (r > 0.5) discard;
            
            // Diamond Core Glow
            float glow = 1.0 - (r * 2.0);
            glow = pow(glow, 2.5); 

            vec3 finalColor = uColor * vColorVariation;
            finalColor += vec3(0.8) * pow(glow, 5.0); // Hot white center

            gl_FragColor = vec4(finalColor, vAlpha * glow);
        }
    </script>

    <script>
        // --- CONFIG ---
        const config = {
            count: 65000,
            camZ: 40,
            color: "#aaddff"
        };

        const loader = document.getElementById('loader');
        const statusText = document.getElementById('status-text');
        const zoomVal = document.getElementById('zoom-val');
        const rotVal = document.getElementById('rot-val');

        // --- THREE.JS ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.012);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = config.camZ;

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- PARTICLE GEN ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(config.count * 3);
        const randoms = new Float32Array(config.count);
        const sizes = new Float32Array(config.count);

        for(let i = 0; i < config.count; i++) {
            let x, y, z, size;
            const r = Math.random();

            if(r < 0.65) { // RINGS
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() > 0.4 ? 14 + Math.random() * 9 : 10 + Math.random() * 2;
                x = Math.cos(angle) * dist;
                z = Math.sin(angle) * dist;
                y = (Math.random() - 0.5) * 0.3;
                size = Math.random() * 2.5;
            } else if (r < 0.80) { // PLANET
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const rad = 7.5;
                x = rad * Math.sin(phi) * Math.cos(theta);
                y = rad * Math.sin(phi) * Math.sin(theta);
                z = rad * Math.cos(phi);
                size = Math.random() * 3.0;
            } else { // DUST
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const rad = Math.random() * 60;
                x = rad * Math.sin(phi) * Math.cos(theta);
                y = rad * Math.sin(phi) * Math.sin(theta);
                z = rad * Math.cos(phi);
                size = Math.random();
            }

            // Initial Tilt
            const tilt = 0.3;
            const ty = y; y = y * Math.cos(tilt) - z * Math.sin(tilt); z = ty * Math.sin(tilt) + z * Math.cos(tilt);

            positions[i*3] = x; positions[i*3+1] = y; positions[i*3+2] = z;
            randoms[i] = Math.random();
            sizes[i] = size;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));
        geometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));

        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColor: { value: new THREE.Color(config.color) },
                uScale: { value: 1.0 }
            },
            vertexShader: document.getElementById('vertexshader').textContent,
            fragmentShader: document.getElementById('fragmentshader').textContent,
            transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- LOGIC VARS ---
        let targetScale = 1.0;
        let currentScale = 1.0;
        let smoothedPinch = 0;
        
        // Rotation Velocity
        let rotVelX = 0;
        let rotVelY = 0;
        let targetRotVelX = 0;
        let targetRotVelY = 0;

        // --- MEDIAPIPE ---
        const videoElement = document.getElementById('input_video');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults((results) => {
            if(loader.style.opacity !== '0') {
                loader.style.opacity = '0';
                setTimeout(() => loader.style.display = 'none', 1000);
            }

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                statusText.innerText = "TRACKING ACTIVE";
                statusText.style.color = "#00ff88";

                const lm = results.multiHandLandmarks[0];
                const wrist = lm[0];
                const indexBase = lm[5];
                const thumbTip = lm[4];
                const indexTip = lm[8];
                const handCenter = lm[9]; // Middle finger knuckle

                // --- 1. ROTATION (JOYSTICK LOGIC) ---
                // X: 0 (Left) -> 1 (Right). Center is 0.5
                // Y: 0 (Top) -> 1 (Bottom). Center is 0.5
                
                // Calculate offset from center (Deadzone 0.1)
                const xOffset = (1.0 - handCenter.x) - 0.5; // Flip X because webcam is mirrored
                const yOffset = handCenter.y - 0.5;

                // Threshold to stop rotation if hand is centered
                const deadzone = 0.1;
                
                if (Math.abs(xOffset) > deadzone) {
                    targetRotVelY = xOffset * 0.05; // Spin speed
                    rotVal.innerText = xOffset > 0 ? "SPIN RIGHT" : "SPIN LEFT";
                } else {
                    targetRotVelY = 0;
                    rotVal.innerText = "HOLDING Y";
                }

                if (Math.abs(yOffset) > deadzone) {
                    targetRotVelX = yOffset * 0.05; // Tilt speed
                } else {
                    targetRotVelX = 0;
                }

                // --- 2. ZOOM (PINCH LOGIC) ---
                const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
                const handSize = Math.hypot(wrist.x - indexBase.x, wrist.y - indexBase.y);
                const normPinch = pinchDist / (handSize || 0.1);

                smoothedPinch += (normPinch - smoothedPinch) * 0.15;

                if (smoothedPinch < 0.25) {
                    targetScale = 0.4; // Shrink
                } else {
                    targetScale = 1.0 + (smoothedPinch - 0.25) * 5.5; // Expand
                }
                
                zoomVal.innerText = targetScale.toFixed(1) + "x";

            } else {
                statusText.innerText = "SEARCHING...";
                statusText.style.color = "#ffaa00";
                rotVal.innerText = "AUTO PILOT";
                
                // Auto Idle Animation
                targetRotVelY = 0.002;
                targetRotVelX = Math.sin(Date.now() * 0.001) * 0.001;
                
                // Breathe
                targetScale = 1.0 + Math.sin(Date.now() * 0.0005) * 0.1;
            }
        });

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cameraUtils.start();

        document.getElementById('colorPicker').addEventListener('input', (e) => {
            material.uniforms.uColor.value.set(e.target.value);
        });

        // --- ANIMATION ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            // Smooth Stats
            currentScale += (targetScale - currentScale) * 0.08;
            rotVelX += (targetRotVelX - rotVelX) * 0.05;
            rotVelY += (targetRotVelY - rotVelY) * 0.05;

            // Apply Rotation
            particles.rotation.y += rotVelY;
            particles.rotation.x += rotVelX;

            // Update Shader
            material.uniforms.uTime.value = time;
            material.uniforms.uScale.value = currentScale;

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
