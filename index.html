<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Saturn: Y-Axis Spin Only</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        
        /* HUD UI */
        #ui-container {
            position: absolute; bottom: 30px; width: 100%;
            display: flex; justify-content: center; pointer-events: none;
            z-index: 10;
        }

        .hud-panel {
            background: rgba(10, 15, 20, 0.75);
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 40px;
            padding: 15px 40px;
            backdrop-filter: blur(12px);
            color: #fff;
            display: flex; gap: 30px; align-items: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
        }

        .stat-group { text-align: center; }
        .stat-label { font-size: 10px; color: #888; letter-spacing: 2px; text-transform: uppercase; margin-bottom: 4px; }
        .stat-value { font-size: 14px; font-weight: 600; color: #fff; font-variant-numeric: tabular-nums; min-width: 60px;}

        /* Physics Colors */
        .fast-speed { color: #ff5555; text-shadow: 0 0 10px rgba(255, 85, 85, 0.5); }
        .slow-speed { color: #00ff88; text-shadow: 0 0 10px rgba(0, 255, 136, 0.5); }

        /* Loader */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 999;
            transition: opacity 1s ease-out; pointer-events: none;
        }
        .loader-text { color: white; font-size: 20px; letter-spacing: 8px; font-weight: 300; opacity: 0.8;}

        /* Video (Hidden) */
        #input_video { position: absolute; opacity: 0; pointer-events: none; z-index: -1; }

        /* Crosshair Helper */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            border: 1px solid rgba(255,255,255,0.1); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="loader">
        <div class="loader-text">NEBULA SYSTEM ONLINE</div>
    </div>

    <div id="crosshair"></div>

    <div id="ui-container">
        <div class="hud-panel">
            <div class="stat-group">
                <div class="stat-label">Zoom</div>
                <div class="stat-value" id="zoom-val">1.0x</div>
            </div>
            
            <div style="width: 1px; height: 25px; background: rgba(255,255,255,0.2);"></div>
            
            <div class="stat-group">
                <div class="stat-label">Spin Speed</div>
                <div class="stat-value slow-speed" id="speed-val">100%</div>
            </div>

            <div style="width: 1px; height: 25px; background: rgba(255,255,255,0.2);"></div>

            <div class="stat-group">
                <div class="stat-label">Status</div>
                <div class="stat-value" id="status-text" style="font-size:11px; color:#888;">INITIALIZING</div>
            </div>
        </div>
    </div>

    <video id="input_video" playsinline></video>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="x-shader/x-vertex" id="vertexshader">
        uniform float uTime;
        uniform float uScale;
        attribute float aRandom;
        attribute float aSize;
        
        varying float vAlpha;
        varying vec3 vColorVariation;

        void main() {
            vec3 pos = position * uScale;
            
            // Warp effect when scaling up
            if(uScale > 3.0) {
                float dist = length(pos.xy);
                pos.z += sin(dist * 0.1 - uTime * 2.0) * 0.5 * (uScale - 1.0);
            }

            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_Position = projectionMatrix * mvPosition;

            // Twinkle
            float twinkle = sin(uTime * 3.0 + aRandom * 25.0);
            twinkle = smoothstep(-1.0, 1.0, twinkle);

            // Dynamic Sizing
            float finalSize = aSize * (0.6 + 0.6 * twinkle);
            gl_PointSize = finalSize * (350.0 / -mvPosition.z);
            
            vAlpha = 0.3 + 0.7 * twinkle;
            vColorVariation = vec3(1.0, 1.0 - aRandom * 0.2, 1.0 + aRandom * 0.2); 
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform vec3 uColor;
        varying float vAlpha;
        varying vec3 vColorVariation;

        void main() {
            float r = length(gl_PointCoord - vec2(0.5));
            if (r > 0.5) discard;
            
            // Diamond Core Glow
            float glow = 1.0 - (r * 2.0);
            glow = pow(glow, 2.5); 

            vec3 finalColor = uColor * vColorVariation;
            finalColor += vec3(0.8) * pow(glow, 5.0); // Hot white center

            gl_FragColor = vec4(finalColor, vAlpha * glow);
        }
    </script>

    <script>
        // --- CONFIG ---
        const config = { count: 65000, camZ: 40, color: "#aaddff" };

        const loader = document.getElementById('loader');
        const statusText = document.getElementById('status-text');
        const zoomVal = document.getElementById('zoom-val');
        const speedVal = document.getElementById('speed-val');

        // --- THREE.JS ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.012);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = config.camZ;

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- PARTICLE GEN ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(config.count * 3);
        const randoms = new Float32Array(config.count);
        const sizes = new Float32Array(config.count);

        for(let i = 0; i < config.count; i++) {
            let x, y, z, size;
            const r = Math.random();

            if(r < 0.65) { // RINGS
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() > 0.4 ? 14 + Math.random() * 9 : 10 + Math.random() * 2;
                x = Math.cos(angle) * dist; z = Math.sin(angle) * dist; y = (Math.random() - 0.5) * 0.3;
                size = Math.random() * 2.5;
            } else if (r < 0.80) { // PLANET
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const rad = 7.5;
                x = rad * Math.sin(phi) * Math.cos(theta); y = rad * Math.sin(phi) * Math.sin(theta); z = rad * Math.cos(phi);
                size = Math.random() * 3.0;
            } else { // DUST
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const rad = Math.random() * 60;
                x = rad * Math.sin(phi) * Math.cos(theta); y = rad * Math.sin(phi) * Math.sin(theta); z = rad * Math.cos(phi);
                size = Math.random();
            }

            // Initial Tilt (Applied to geometry so it persists without X-axis rotation)
            const tilt = 0.4;
            const ty = y; y = y * Math.cos(tilt) - z * Math.sin(tilt); z = ty * Math.sin(tilt) + z * Math.cos(tilt);

            positions[i*3] = x; positions[i*3+1] = y; positions[i*3+2] = z;
            randoms[i] = Math.random();
            sizes[i] = size;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));
        geometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));

        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColor: { value: new THREE.Color(config.color) },
                uScale: { value: 1.0 }
            },
            vertexShader: document.getElementById('vertexshader').textContent,
            fragmentShader: document.getElementById('fragmentshader').textContent,
            transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- LOGIC VARS ---
        let targetScale = 1.0;
        let currentScale = 1.0;
        let smoothedPinch = 0;
        let rotVelY = 0;
        let targetRotVelY = 0;

        // --- MEDIAPIPE ---
        const videoElement = document.getElementById('input_video');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults((results) => {
            if(loader.style.opacity !== '0') {
                loader.style.opacity = '0';
                setTimeout(() => loader.style.display = 'none', 1000);
            }

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                statusText.innerText = "ONLINE";
                statusText.style.color = "#00ff88";

                const lm = results.multiHandLandmarks[0];
                const wrist = lm[0];
                const indexBase = lm[5];
                const thumbTip = lm[4];
                const indexTip = lm[8];
                const handCenter = lm[9]; 

                // --- ROTATION (X-AXIS INPUT -> Y-AXIS SPIN) ---
                const xOffset = (1.0 - handCenter.x) - 0.5; // Flip X for mirror effect
                
                // Deadzone
                const deadzone = 0.08;
                
                if (Math.abs(xOffset) > deadzone) {
                    targetRotVelY = xOffset * 0.08; 
                } else {
                    targetRotVelY = 0;
                }
                
                // Note: We intentionally IGNORE Y-Offset (Hand up/down) to prevent rolling.

                // --- ZOOM (PINCH) ---
                const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
                const handSize = Math.hypot(wrist.x - indexBase.x, wrist.y - indexBase.y);
                const normPinch = pinchDist / (handSize || 0.1);

                smoothedPinch += (normPinch - smoothedPinch) * 0.15;

                if (smoothedPinch < 0.25) targetScale = 0.4; // Shrink
                else targetScale = 1.0 + (smoothedPinch - 0.25) * 5.5; // Expand

            } else {
                statusText.innerText = "SEARCHING...";
                statusText.style.color = "#ffaa00";
                
                // Auto Idle Animation
                targetRotVelY = 0.002;
                targetScale = 1.0 + Math.sin(Date.now() * 0.0005) * 0.1;
            }
        });

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cameraUtils.start();

        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            // 1. Smooth Scale
            currentScale += (targetScale - currentScale) * 0.08;

            // 2. Physics Factor (Slower spin when zoomed in)
            let physicsFactor = 1.0 / Math.max(1.0, currentScale * 1.5);

            // 3. Smooth Rotation Velocity
            rotVelY += (targetRotVelY - rotVelY) * 0.05;

            // 4. Apply Rotation (ONLY Y-AXIS)
            particles.rotation.y += rotVelY * physicsFactor;
            
            // Note: particles.rotation.x is NOT updated, preventing tumbling.

            // 5. Update Shader
            material.uniforms.uTime.value = time;
            material.uniforms.uScale.value = currentScale;

            // 6. Update UI
            zoomVal.innerText = currentScale.toFixed(1) + "x";
            
            const speedPercent = Math.round(physicsFactor * 100);
            speedVal.innerText = speedPercent + "%";
            
            if(speedPercent < 40) speedVal.className = "stat-value slow-speed";
            else speedVal.className = "stat-value fast-speed";

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
